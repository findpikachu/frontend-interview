# 实现任务队列机制

## 前言

在 JavaScript 中，事件循环（Event Loop）是理解异步编程的核心概念。它通过任务队列机制来管理和执行不同类型的任务，确保代码的有序执行。本文将深入探讨如何实现一个简化版的任务队列机制，帮助理解 JavaScript 的异步执行原理。

## 核心概念

### 1. 任务类型

JavaScript 中的任务主要分为两类：

- **微任务（Microtask）**：如 `Promise.then()`、`queueMicrotask()` 等
- **宏任务（Macrotask）**：如 `setTimeout()`、`setInterval()`、DOM 事件等

### 2. 执行优先级

事件循环的执行顺序遵循以下规则：

1. 执行当前同步代码
2. 执行所有微任务，直至微任务队列为空
3. 执行一个宏任务
4. 重复步骤 2-3

## 实现

- 使用 `setTimeout(eventLoop, 0)` 将事件循环的执行推迟到下一个宏任务
- 确保当前同步代码执行完毕后再开始处理队列中的任务
- 所有微任务必须在下一个宏任务之前执行完毕
- 微任务执行过程中产生的新微任务会立即加入当前循环

```javascript
const microTaskQueue = [];
const macroTaskQueue = [];
let isExecuting = false;

// 添加微任务
const pushMicro = (fn) => {
  microTaskQueue.push(fn);
  // 如果当前没有在执行任务循环，则启动
  if (!isExecuting) {
    scheduleEventLoop();
  }
};

// 添加宏任务
const pushMacro = (fn) => {
  macroTaskQueue.push(fn);
  // 如果当前没有在执行任务循环，则启动
  if (!isExecuting) {
    scheduleEventLoop();
  }
};

const scheduleEventLoop = () => {
  setTimeout(eventLoop, 0);
};

const eventLoop = () => {
  if (isExecuting) return;
  isExecuting = true;
  
  try {
    // 执行所有微任务，直至微任务队列为空
    while (microTaskQueue.length > 0) {
      const microTask = microTaskQueue.shift();
      microTask();
    }
    
    // 执行一个宏任务（如果有的话）
    if (macroTaskQueue.length > 0) {
      const macroTask = macroTaskQueue.shift();
      macroTask();
    }
    
    // 如果还有任务需要处理，继续下一轮事件循环
    if (microTaskQueue.length > 0 || macroTaskQueue.length > 0) {
      scheduleEventLoop();
    }
  } finally {
    isExecuting = false;
  }
};
const run=()=>{
  console.log('a')
  pushMicro(()=>{
    console.log('b');
    pushMicro(()=>{
      console.log('c')
    })
    pushMacro(()=>{
      console.log('d')
    })
  })
  pushMacro(()=>{
    console.log('e');
  })
  console.log('f')
}
run();
// 输出：a, f, b, c, e, d
```

### 执行流程分析

1. **同步代码阶段**：

   - 执行 `console.log('a')`
   - 将微任务和宏任务添加到相应队列
   - 执行 `console.log('f')`

2. **第一轮事件循环**：

   - 执行微任务：输出 'b'
   - 在微任务中添加新的微任务和宏任务
   - 继续执行新添加的微任务：输出 'c'
   - 微任务队列清空

3. **第二轮事件循环**：

   - 执行一个宏任务：输出 'e'

4. **第三轮事件循环**：
   - 执行一个宏任务：输出 'd'


## 应用场景

### 1. Promise 链式调用

```javascript
pushMicro(() => console.log("Promise 1"));
pushMicro(() => console.log("Promise 2"));
pushMacro(() => console.log("Timer"));
// 输出：Promise 1, Promise 2, Timer
```

### 2. 任务优先级控制

```javascript
// 高优先级任务使用微任务
pushMicro(() => console.log("高优先级"));
// 低优先级任务使用宏任务
pushMacro(() => console.log("低优先级"));
```

### 3. 异步任务编排

```javascript
pushMacro(() => {
  console.log("异步任务开始");
  pushMicro(() => {
    console.log("清理工作");
  });
});
```

## 总结

通过实现一个简化版的任务队列机制，我们可以更深入地理解到事件循环是通过任务队列机制来管理和执行异步任务，微任务始终优先于宏任务执行

任务队列机制是JavaScript 异步编程的核心，它可以更好的理解 Promise、async/await 等现代异步特性。
