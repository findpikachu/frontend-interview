# 发布订阅模式和观察者模式傻傻的分不清楚

发布订阅模式和观察者模式都是为了解决对象间通信解耦合的，他们都是一对多的状态，当一个对象状态更新，所有依赖他的对象都会收到通知，但是他们之间的区别就是是否有个中介。接下来我会带你一一去探究他们之间的实现和不同。

## 观察者模式

观察者模式是当主题(subject)被订阅后，当 subject 状态变化后，所有订阅 subject 的观察者(Observer)都会收到通知。
例如 父母和老师是观察者，而学生是被观察者， 当学生的考试成绩出来后，父母和老师就会接受到通知。

在这个过程中，父母老师和学生是直接知道对方的存在的，因为学生持有他们的引用。他们之间是松散耦合的。

### 实现

```js
// 被观察者（Subject）
class Subject {
  observers = [];
  state = null;
  addObserver(observer) {
    this.observers.push(observer);
  }

  removeObserver(observer) {
    this.observers = this.observers.filter((o) => o !== observer);
  }

  notify() {
    this.observers.forEach((o) => o.update(this.state));
  }

  setState(state) {
    this.state = state;
    this.notify();
  }
}

class Observer {
  update(state) {
    throw new Error("update() must be implemented");
  }
}

class Student extends Subject {
  constructor(name) {
    super();
    this.name = name;
    this.score = 0;
  }

  setScore(score) {
    console.log(`${this.name}的成绩更新为: ${score}`);
    this.setState({ name: this.name, score: score });
  }
}

class Parent extends Observer {
  constructor(name) {
    super();
    this.name = name;
  }

  update(state) {
    console.log(
      `家长${this.name}收到通知: ${state.name}的成绩是${state.score}分`
    );
  }
}

class Teacher extends Observer {
  constructor(name) {
    super();
    this.name = name;
  }

  update(state) {
    console.log(
      `老师${this.name}收到通知: ${state.name}的成绩是${state.score}分`
    );
    if (state.score < 60) {
      console.log(`老师${this.name}: ${state.name}需要补习`);
    }
  }
}

console.log("=== 观察者模式测试 ===");

// 创建学生
const student = new Student("小明");

// 创建观察者
const parent1 = new Parent("小明妈妈");
const parent2 = new Parent("小明爸爸");
const teacher = new Teacher("张老师");

// 添加观察者
student.addObserver(parent1);
student.addObserver(parent2);
student.addObserver(teacher);

// 学生成绩变化，自动通知所有观察者
console.log("\n--- 第一次成绩更新 ---");
student.setScore(85);

console.log("\n--- 第二次成绩更新 ---");
student.setScore(45);

// 移除一个观察者
console.log("\n--- 移除家长观察者后 ---");
student.removeObserver(parent1);
student.setScore(92);
```

## 发布订阅模式

发布订阅模式和观察者模式类似，也是一对多的关系，当对象状态发生变化会通知对方，但是他们的不同就是发布订阅模式有一个中介，订阅者和发布者都不知道对方的存在，他们都是通过中介去通信的。

例如 b 站 是个中介，而 up 主是发布者， 用户是订阅者， up 主只需要上传视频到 b 站，并打上对应的 tag。up 主并不知道用户是谁，也不需要关心。
而用户订阅者只需要和 b 站打交道，他们只需要订阅了这个 tag，b 站就会发送消息给它们。他们之间是完全耦合的。

### 实现

```js
class EventEmitter {
  listeners = [];
  on(eventName, listener) {
    this.listeners[eventName] = this.listeners[eventName] ?? [];
    this.listeners[eventName].push(listener);
  }
  emit(eventName, ...args) {
    this.listeners[eventName]?.forEach((listener) => {
      listener(...args);
    });
  }

  off(eventName, listener) {
    this.listeners[eventName] =
      this.listeners[eventName]?.filter((cb) => cb !== listener) ?? [];
  }

  once(eventName, listener) {
    if (this.listeners[eventName]?.includes(listener)) {
      return;
    }

    this.on(eventName, listener);
  }
}
```

## 核心区别

| 特性         | 观察者模式                           | 发布订阅模式                             |
| ------------ | ------------------------------------ | ---------------------------------------- |
| **耦合度**   | 松散耦合                             | 完全解耦                                 |
| **中介**     | 无中介，直接通信                     | 有中介（事件中心/消息队列）              |
| **通信方式** | 通常是同步（直接调用）       | 通过异步（中介转发）                   |
| **依赖关系** | Subject 和 Observer 相互知道对方存在 | Publisher 和 Subscriber 互不知道对方存在 |
| **使用场景** | 单一应用内部，关系明确             |  跨应用，大型模块系统                       |



## 结论

观察者模式和发布订阅模式都是解决对象间通信问题的优秀设计模式，选择哪种模式主要取决于具体的应用场景：

### 选择观察者模式的场景

- 对象间有明确的依赖关系
- 系统相对简单，不需要复杂的事件管理
- 性能要求较高（直接调用，无中介开销）
- 如：MVC 架构中 Model 和 View 的关系

### 选择发布订阅模式的场景

- 需要完全解耦的系统架构
- 复杂的事件驱动系统
- 需要跨模块、跨组件通信
- 如：前端框架的事件系统、Node.js 的 EventEmitter、消息队列系统

两种模式各有优势，理解它们的核心区别有助于在实际开发中做出正确的架构选择。记住关键点：**观察者模式是直接通信，发布订阅模式是通过中介通信**。
