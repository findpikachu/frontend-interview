# 数组扁平化

## 前言

数组扁平化是前端开发中经常遇到的一个问题，特别是在处理嵌套数组结构时。简单来说，数组扁平化就是将多维数组转换为一维数组的过程。

例如，将多维数组`[1, [2, [3, [4, 5]]]]` 转换为一维数组是 `[1, 2, 3, 4, 5]`。

本文将介绍四种不同的数组扁平化实现方法：ES5 递归实现、reduce 方法、扩展运算符以及迭代方式，每种方法都有其特点和适用场景。

## ES5 递归实现

- 循环遍历数组
- 判断元素是否是数组类型并且递归深度是否大于 0
- 如果是，递归当前元素，否则直接把元素放到结果数组中

```js
function flatArray(arr, depth) {
  depth = depth === undefined ? 1 : depth;
  var result = [];
  function flatten(array, currentDepth) {
    for (var i = 0; i < array.length; i++) {
      const element = array[i];
      if (Array.isArray(element) && currentDepth > 0) {
        flatten(element, currentDepth - 1);
      } else {
        result.push(element);
      }
    }
  }

  flatten(arr, depth);
  return result;
}
```

## reduce

reduce 方法的第一个参数是一个函数，第二个参数是初始值，这里我们使用 concat 方法把元素放到结果数组中，最后返回结果数组

```js
function flatArray(arr, depth = 1) {
  if (depth === 0 || !Array.isArray(arr)) return arr;
  return arr.reduce((acc, cur) => acc.concat(flatArray(cur, depth - 1)), []);
}
```

## spread

数组的 some 方法去查找第一个函数返回 true 的元素，否则的话就一直到末尾，返回 false

```js
[1, [2, 3], 3, 4, [5, 6]].some((item) => Array.isArray(item)); // [2,3]
```

接下来我们用 concat 和...展开符来实现数组的扁平化

- while 循环遍历数组，只要数组中有是元素的数组就一直循环，一直到数组完全扁平化
- 如果有元素是数组，使用...运算符把元素扁平，concat 合并数组

```js
function flatArray(arr) {
  while (arr.some(Array.isArray)) {
    arr = [].concat(...arr);
  }
  return arr;
}
```

## 迭代

我们使用 stack 数据结构实现迭代，stack 是后进先出的数据结构，所以我们使用数组的 pop 方法来取出最后一个元素，这样就可以保证数组的顺序不会被破坏。

- 使用 map 方法把数组中的元素和深度放到 stack 中
- 使用 while 循环遍历 stack，如果元素是数组并且深度大于 0，就把元素的子元素和深度-1 放到 stack 中
- 如果元素不是数组，就把元素放到结果数组中
- 最后把结果数组反转一下，因为 stack 是后进先出的数据结构

```js
function flatArray(arr, depth = 1) {
  const stack = [...arr.map((item) => [item, depth])];
  const result = [];
  while (stack.length) {
    const [item, currentDepth] = stack.pop();
    if (Array.isArray(item) && currentDepth > 0) {
      stack.push(...item.map((subItem) => [subItem, currentDepth - 1]));
    } else {
      result.push(item);
    }
  }

  return result.reverse();
}
```

## 比较

- **ES5 递归实现**：兼容性好，但嵌套比较深的可能会导致栈溢出。
- **reduce**：代码更少，完全支持深度定制。
- **spread**：代码虽然简洁，但是不支持深度定制，只能完全扁平化。
- **迭代**：避免堆栈溢出，适合嵌套比较深的数组。

## 总结

在实际开发中，根据不同的场景来使用不同的flat实现。
- 简单场景，测试中使用 `Array.prototype.flat()` 原生方法
- 深度控制，可以使用spread, reduce, 迭代等实现
- 深层嵌套，使用迭代实现
- 兼容性要求，ES5 递归实现兼容性最好

**性能考虑：**

- 浅层嵌套：spread 方法性能最佳
- 深层嵌套：迭代方法更安全稳定
- 中等复杂度：reduce 方法平衡了代码可读性和性能

通过掌握这些不同的实现方式，可以根据具体的业务场景和技术要求选择最合适的数组扁平化方案。
